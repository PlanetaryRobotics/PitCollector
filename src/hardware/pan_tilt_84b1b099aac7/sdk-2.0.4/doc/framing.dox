/**

\page Framing Framing

The new binary protocol for E-series devices is framed for reliability.
It provides fast synchronization and allows rejection of common transmission
errors.

There are six components to the frame:

\li Start-of-Frame Marker
\li Length
\li Echo Field
\li Payload (direction dependent fields)
\li Cyclic Redundancy Check
\li End-of-Frame Marker

Command frame:
<table>
<tr>
    <td>SOF<br>1 byte</td>
    <td>Length<br>1 byte</td>
    <td>Echo<br>1 byte</td>
    <td>Opcode<br>2 bytes</td>
    <td>Arguments<br>0+ bytes</td>
    <td>CRC<br>2 bytes</td>
    <td>EOF<br>1 byte</td>
</tr>
</table>

Reply frame:
<table>
<tr>
    <td>SOF<br>1 byte</td>
    <td>Length<br>1 byte</td>
    <td>Echo<br>1 byte</td>
    <td>Status<br>2 bytes</td>
    <td>Returns<br>0+ bytes</td>
    <td>CRC<br>2 bytes</td>
    <td>EOF<br>1 byte</td>
</tr>
</table>

\section encoding Frame Encoding

The frame echo field, payload, and CRC are encoded with Consistent Overhead
Byte Stuffing
(http://conferences.sigcomm.org/sigcomm/1997/papers/p062.pdf). This is a
byte-stuffing technique which has a well defined overhead and guarantees a
specific byte will not appear in the encoded data.

Cheshire and Baker's COBS paper defines ASCII NUL (0x00) as the illegal byte.
This implementation is slightly modified to use the ASCII SPACE character
(0x20) instead.

Refer to \ref cfrm.c for details on the SDK's COBS variant.


\section SOF Start-of-Frame Marker

The SOF marker is a single byte that marks the start of a new frame. This
marker gives a receiver positive reinforcement that a new frame has arrived. 

SOF is defined as 0xFA. This byte was chosen because it is not a defined
D-generation binary opcode.

\section length Length

The length field is 8 bits. It is the length of the data in the payload (echo, 
opcode or status, arguments or returns, and CRC) plus the hexadecimal value 0x21. The 
length value does not include the SOF, length, or EOF fields. 

\section echo Echo Field

The echo field is 8 bits of data that is received by the PTU and echoed back in
the PTU's reply. This field also contains sequencing bits in the reply. Only
the lower four bits are echoed by the PTU. The upper four bits is an
incrementing sequence number from the PTU.

\section payload Payload

The frame payload layout changes depending on the direction; that is, a command
to the PTU is different from a reply from the PTU.

\subsection opcode Opcode

Command frames contain a code that tells the PTU what operation to execute.
It is 16 bits wide. See \ref cpi_opcode and \ref opxref
"the opcode cross-reference" for details.

\subsection status Status

Reply frames contain a status code. This code is a bit-vector of flags for the
frame. For example, if the error bit is set, then the return value is to be
decoded as a error code instead of the opcode's prescribed return value format.

\subsection enc_args_rets Argument and Return Values

Command frames may contain arguments after the opcode and reply frames may
contain returns. Arguments and returns are encoded as signed or unsigned
integers, floating-point doubles, and strings. Enumerated types are encoded as
integers. ASCII strings and binary strings are encoded identically as a length
encoded string.

Integers are 32 bits wide, big-endian, and in twos-complement form.

Doubles are big-endian, normalized, IEEE 754 floating point numbers. Every
opcode expects or generates a real number. As such, NaN, infinity, and other
floating representations result in undefined behavior.

Strings are length encoded. The first 16 bits are a big-endian unsigned integer
of the string length. The follow bytes is the string data.

\section CRC Cyclic Redundancy Check

A CRC is used to to protect the frame's data. See \ref crc_cfrm for details.

\section EOF End-of-Frame Marker

An EOF marker is used to mark the end of a frame. This marker is defined as the
COBS illegal byte (0x20) which, when received, forces a restart of a COBS
stream decoder. 0x20 also forces a restart of the ASCII protocol's decoder,
allowing both the ASCII and binary parsers to coexist.

*/

